# mcp-echarts 系统总体设计

本文档是对 `mcp-echarts` 项目的总体架构分析，旨在为后续的重构工作提供清晰的蓝图。

## 1. 核心概念（Metaphors）

为了更好地理解系统，我们可以使用 “名词、动词、引擎、点火钥匙” 的比喻来描述其核心组件。

| 比喻 | 核心组件 | 描述 |
| :--- | :--- | :--- |
| **名词 (Nouns)** | ECharts Option, 输入数据, 输出结果 | 系统处理的核心数据。`输入数据` 经过处理，生成 ECharts `Option` 对象（图表的完整声明式定义），最终转化为`输出结果`（如 PNG 图片、SVG 文本或 MinIO URL）。 |
| **动词 (Verbs)** | `run()`, `renderECharts()`, `generateChartImage()` | 系统执行的关键操作。`run` 将输入转化为 Option；`renderECharts` 将 Option 渲染成图形；`generateChartImage` 负责协调渲染、存储和格式化输出。 |
| **引擎 (Engine)** | `src/utils/render.ts` | 系统的核心动力来源。它利用 `@napi-rs/canvas` 在 Node.js 后端环境中模拟出一个画布，并驱动 ECharts 在上面进行绘制，从而生成图片，完全脱离浏览器环境。 |
| **点火钥匙 (Ignition Key)** | `src/index.ts` | 启动整个应用的入口。它负责解析命令行参数，启动 `McpServer` 服务，并动态地发现和注册所有位于 `src/tools` 目录下的图表生成工具。 |

## 2. 架构流程

本系统采用高度模块化、插件化的架构。所有图表类型（如柱状图、折线图）都作为独立的“工具”存在，由一个统一的服务器进行调度和执行。

### 流程图 (Flowchart)

```mermaid
graph TD
    A[客户端通过 MCP 协议发起请求] --> B{src/index.ts: McpServer};
    B --> C{工具调度器};
    C --> D[src/tools/*.ts: run()];
    D --> E{数据转换};
    E --> F[构建 ECharts Option 对象];
    F --> G[src/utils/imageHandler.ts: generateChartImage()];
    G --> H[src/utils/render.ts: renderECharts()];
    H -- PNG --> I[使用 @napi-rs/canvas];
    H -- SVG --> J[使用 ECharts SVG 渲染器];
    I --> K[图片 Buffer];
    J --> L[SVG 字符串];
    K --> M{是否配置了 MinIO?};
    M -- 是 --> N[上传至 MinIO];
    N --> O[返回图片 URL];
    M -- 否 --> P[返回 Base64 编码图片];
    L --> Q[返回 SVG 字符串];
    subgraph "响应格式化"
        O --> R[MCP 标准响应];
        P --> R;
        Q --> R;
    end
    R --> S[客户端];
```

### 时序图 (Sequence Diagram)

此图展示了一个典型的客户端请求、处理和响应的完整过程。

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant McpServer (index.ts) as MCP服务器
    participant Tool (e.g., bar.ts) as 图表工具
    participant ImageHandler (imageHandler.ts) as 图像处理器
    participant Renderer (render.ts) as 渲染引擎
    participant MinIO (minio.ts) as 对象存储

    Client->>McpServer: Request('generate_bar_chart', {data: ...})
    McpServer->>Tool: run({data: ...})
    Tool->>Tool: 转换数据, 构建 ECharts Option
    Tool->>ImageHandler: generateChartImage(option, width, height)
    ImageHandler->>Renderer: renderECharts(option, width, height)
    Renderer->>Renderer: createCanvas() & echarts.init(canvas)
    Renderer-->>ImageHandler: 返回 PNG Buffer
    ImageHandler->>MinIO: isMinIOConfigured()
    alt MinIO 已配置
        MinIO-->>ImageHandler: true
        ImageHandler->>MinIO: storeBufferToMinIO(buffer)
        MinIO-->>ImageHandler: 返回 'http://...'
        ImageHandler-->>Tool: 返回 {content: [{type:'text', text:'http://...'}]}
    else MinIO 未配置
        MinIO-->>ImageHandler: false
        ImageHandler->>ImageHandler: buffer.toString('base64')
        ImageHandler-->>Tool: 返回 {content: [{type:'image', data:'...'}]}
    end
    Tool-->>McpServer: 返回 MCP 响应
    McpServer-->>Client: 发送 MCP 响应
```

## 3. 工具设计哲学：易用性与灵活性的平衡

本项目提供两类图表生成工具，旨在兼顾易用性与灵活性。

*   **简化版工具 (Simplified Tools)**
    *   **代表**: `generate_bar_chart`, `generate_line_chart` 等。
    *   **特点**: 这些工具提供了高度封装的、面向特定图表类型的接口。它们将复杂的 ECharts 配置项抽象为少数几个简单、直观的参数（如 `title`, `stack`）。
    *   **优点**: 使用简单，无需了解 ECharts 的深层细节即可快速生成标准图表。API 契约清晰，易于验证。
    *   **局限**: 无法实现高度自定义的、复杂的图表效果，因为大部分 ECharts 配置项未被暴露。

*   **通用版工具 (Generic Tool)**
    *   **代表**: `generate_echarts`。
    *   **特点**: 该工具的核心是允许用户直接传入一个完整的、原生的 ECharts `Option` JSON 字符串。
    *   **优点**: 提供了最大的灵活性。任何可以通过 ECharts `Option` 实现的图表，都可以通过此工具生成，没有任何限制。这是高级用户的“后门”。
    *   **局限**: 要求使用者对 ECharts 的 `Option` 结构非常熟悉，使用门槛较高。

这种双层设计满足了不同用户的需求：大部分常见需求可以通过简化版工具快速满足，而复杂的、个性化的需求则可以通过通用版工具得到解决。

## 4. 服务模式：作为“被调用者”的微服务

一个常见的误区是认为本项目是一个需要配合其他后端服务使用的“库”。实际上，**本项目本身就是一个功能完整的、独立的后端服务**，更准确地说，是一个“工具微服务”。

它的核心设计模式是“被调用者”，而非“调用者”。这意味着：

*   **它是一个服务端**: 从 `src/index.ts` 可以看出，它能以多种形式启动一个服务：
    *   **HTTP 服务器**: 使用 `express` 启动一个监听特定端口的 Web 服务。
    *   **Stdio 服务**: 作为一个命令行工具，通过标准输入/输出与父进程通信。
*   **它等待客户端调用**: 它被设计为等待一个外部“客户端”来调用其提供的工具。这个客户端可以是：
    *   一个 AI Agent 或大语言模型应用。
    *   另一个需要图表生成功能的后端服务。
    *   一个自动化脚本。

因此，思考此项目的正确心智模型是：**不需要为它编写一个配合的后端，而是需要一个调用它的客户端**。它将图表生成这项具体功能封装成了一个可通过网络或进程间通信调用的、独立的微服务。

## 5. 关键模块索引

以下是系统中最核心的10个文件/模块的分析文档链接。理解这些文件是理解整个系统的关键。

1.  [`src/index.ts`](./01_src_index.ts.md) - **点火钥匙**: 应用主入口和服务器设置。
2.  [`src/utils/render.ts`](./02_src_utils_render.ts.md) - **引擎**: 核心的图表渲染逻辑。
3.  [`src/utils/imageHandler.ts`](./03_src_utils_imageHandler.ts.md) - **输出协调器**: 处理渲染后的图像，负责格式化、存储和返回。
4.  [`src/tools/bar.ts`](./04_src_tools_bar.ts.md) - **工具范例**: 一个标准的图表工具实现，可作为所有工具的参考模板。
5.  [`src/tools/index.ts`](./05_src_tools_index.ts.md) - **工具注册中心**: 汇总并导出所有可用的图表工具。
6.  [`src/utils/schema.ts`](./06_src_utils_schema.ts.md) - **API 契约**: 定义了所有工具统一的输入参数 schema，确保接口一致性。
7.  [`package.json`](./07_package.json.md) - **项目基石**: 定义了项目依赖、脚本和入口点。
8.  [`src/utils/minio.ts`](./08_src_utils_minio.ts.md) - **外部存储**: 实现了将生成图片上传到 S3 兼容对象存储的功能。
9.  [`src/tools/line.ts`](./09_src_tools_line.ts.md) - **工具范例2**: 第二个标准工具，用于对比和理解工具的共性与个性。
10. [`__tests__/integration.spec.ts`](./10___tests___integration.spec.ts.md) - **使用说明书**: 集成测试，展示了从外部调用工具的实际用例。
